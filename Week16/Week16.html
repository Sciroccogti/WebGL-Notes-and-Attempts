<!DOCTYPE html>
<html lang="zh-cn">

<head>
    <title>Week 16 try</title>
    <meta charset="utf-8">

</head>
<!-- 实验内容：
4、 纹理映射：掌握几种映射方法及WebGL中的纹理映射的设置方法。
构建一个场景，综合本学期所学建模、变换、观察和光照技术，并增加纹理贴图，实现下面几种效果：
（1）	贴图固定在物体表面，随物体变动
（2）	纹理场效果
   拓展功能：
（1）	导入网格模型（网上下载、程序生成或由Unity3D、3d max等建模软件导出）
（2）	生成环境映射/凹凸映射 -->

<body>
  <script src="../threejs/clock.js"></script>
  <script type="module">

      import * as THREE from '../threejs/three.module.js';
      import { GUI } from '../threejs/dat.gui.module.js';
      import { OrbitControls } from '../threejs/OrbitControls.js';
      import { Water } from '../threejs/Water2.js';

      var camera, scene, renderer, texture, mesh, gui;


          clock();
          init();
          animate();

      function init(){

          camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
          camera.position.set(0, 200, 200);

          scene = new THREE.Scene();
          scene.background = new THREE.Color(0xa0a0a0);

          var bump = new THREE.TextureLoader().load("../jpg/t.jpg");
          var normal = new THREE.TextureLoader().load("../jpg/t.jpg");
          var material1 = new THREE.MeshPhongMaterial({
              map:normal
          });
          material1.bumpMap = bump;
          material1.bumpScale = 0.5;

          var geometry = new THREE.CubeGeometry(150, 150, 150,4,4);
          texture = new THREE.Texture( canvas);
          var material = new THREE.MeshBasicMaterial({map:texture});
          texture.needsUpdate = true;
          mesh = new THREE.Mesh( geometry,material );
          mesh.position.set(0,150,0);
          scene.add( mesh );

          var geometry = new THREE.CubeGeometry(150,75,150,4,4);
          //var material = new THREE.MeshLambertMaterial({color:0xffffff});
          var mesh2 = new THREE.Mesh(geometry,material1);
          mesh2.position.set(0,37.5,0);
          scene.add(mesh2);

          var mesh3 = new THREE.Mesh( new THREE.PlaneBufferGeometry( 20000, 20000 ), new THREE.MeshPhongMaterial( { color: 0xffffff, depthWrite: false } ) );
          mesh3.rotation.x = - Math.PI / 2;
          mesh3.receiveShadow = true;
          scene.add( mesh3 );

          var grid = new THREE.GridHelper( 2000, 50, 0x000000, 0x000000 );
          grid.material.opacity = 0.2;
          grid.material.transparent = true;
          grid.rotation.y = - Math.PI / 2;
          scene.add( grid );

          var ambientLight = new THREE.AmbientLight(0x444444,0.4);
          scene.add(ambientLight);
          var directionallight = new THREE.DirectionalLight(0xffffff);
          directionallight.position.set(10, 10, 10 );
          directionallight.castShadow = true;
          directionallight.shadow.camera.top = 10;
          directionallight.shadow.camera.bottom = -10;
          directionallight.shadow.camera.left = -10;
          directionallight.shadow.camera.right = 10;
          scene.add(directionallight);
/*
          gui = {
              bump:0.03
          };
          var datGui = new dat.GUI();
          datGui.add(gui, "bump", -1, 1).onChange(function (e) {
              mesh2.material.bumpScale = e;
          });
          datGui.open();
*/
          renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.shadowMap.enabled = true;
          document.body.appendChild(renderer.domElement);

          var controls = new OrbitControls(camera, renderer.domElement);
          window.addEventListener('resize', onWindowResize, false);

      }
      function onWindowResize() {

          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();

          renderer.setSize(window.innerWidth, window.innerHeight);

      }
      function animate() {

          texture.needsUpdate = true;
          requestAnimationFrame(animate);
          render();
      }

      function render() {

          var time = Date.now() / 6000;
          renderer.render(scene, camera);
      }
  </script>
</body>

</html>